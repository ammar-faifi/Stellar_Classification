[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "site",
    "section": "",
    "text": "To learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html#data",
    "href": "index.html#data",
    "title": "Stellar Classification",
    "section": "Data",
    "text": "Data\nthe Stellar Classification Dataset - SDSS17data was obtained from kaggle\nthe dataset has the following attributes\n\n\n\n\n\n\n\n\n\ncolumn\ndescription\n\n\n\n\n1\nobj_ID\nObject Identifier, the unique value that identifies the object in the image catalog used by the CAS\n\n\n2\nalpha\nRight Ascension angle (at J2000 epoch)\n\n\n3\ndelta\nDeclination angle (at J2000 epoch)\n\n\n4\nu\nUltraviolet filter in the photometric system\n\n\n5\ng\nGreen filter in the photometric system\n\n\n6\nr\nRed filter in the photometric system\n\n\n7\ni\nNear Infrared filter in the photometric system\n\n\n8\nz\nInfrared filter in the photometric system\n\n\n9\nrun_ID\nRun Number used to identify the specific scan\n\n\n10\nrereun_ID\nRerun Number to specify how the image was processed\n\n\n11\ncam_col\nCamera column to identify the scanline within the run\n\n\n12\nfield_ID\nField number to identify each field\n\n\n13\nspec_obj_ID\nUnique ID used for optical spectroscopic objects (this means that 2 different observations with the same spec_obj_ID must share the output class)\n\n\n14\nclass\nobject class (galaxy, star or quasar object)\n\n\n15\nredshift\nredshift value based on the increase in wavelength\n\n\n16\nplate\nplate ID, identifies each plate in SDSS"
  },
  {
    "objectID": "index.html#team-members",
    "href": "index.html#team-members",
    "title": "Stellar Classification",
    "section": "Team members",
    "text": "Team members\nAhmed Almohammed Turki Alsaedi Sultan Alkadhi Salman Al-Harbi Ammar Alfaifi Lana almorabah"
  },
  {
    "objectID": "KNN_and_XGB.html",
    "href": "KNN_and_XGB.html",
    "title": "KNN & XGB",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nplt.rcParams[\"figure.dpi\"] = 170\nplt.style.use(\"seaborn\")\n\nimport xgboost as xgb\nfrom sklearn.model_selection import (\n    train_test_split,\n    KFold,\n    GridSearchCV,\n    cross_val_score,\n    RandomizedSearchCV,\n)\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.inspection import permutation_importance\nfrom sklearn.metrics import RocCurveDisplay\n\n# import warnings filter\nfrom warnings import simplefilter\n\n# ignore all future warnings\nsimplefilter(action=\"ignore\", category=FutureWarning)"
  },
  {
    "objectID": "KNN_and_XGB.html#basic-knn-with-5-fold-cv",
    "href": "KNN_and_XGB.html#basic-knn-with-5-fold-cv",
    "title": "KNN & XGB",
    "section": "Basic KNN with 5-Fold CV",
    "text": "Basic KNN with 5-Fold CV\n\n\nCode\nscaler = StandardScaler()\n# standardize all columns\nX_train_std = scaler.fit_transform(X_train)\n\n# create KNN model\nknn = KNeighborsClassifier(n_neighbors=5)\n\n# create 5-Fold CV\nkfold = KFold(n_splits=5, random_state=123, shuffle=True)\n\n# Fit the model\nresults = cross_val_score(knn, X_train_std, y_train, cv=kfold, scoring='accuracy')\n\nprint(max(results))\n\n\n0.9255714285714286"
  },
  {
    "objectID": "KNN_and_XGB.html#tuning-the-knn-model",
    "href": "KNN_and_XGB.html#tuning-the-knn-model",
    "title": "KNN & XGB",
    "section": "Tuning the KNN Model",
    "text": "Tuning the KNN Model\n\nCode\n# hyper parameters for CV\nhyper_params = {\n    'n_neighbors': range(1, 10+1)\n}\n\nscaler = StandardScaler()\n# standardize all columns\nX_train_std = scaler.fit_transform(X_train)\n\n# create KNN model\nknn = KNeighborsClassifier()\n\n# create 5-Fold CV\nkfold = KFold(n_splits=5, random_state=123, shuffle=True)\n\n# Tune `knn` using grid search\ngrid_search = GridSearchCV(knn, hyper_params, cv=kfold, scoring='accuracy')\ngrid_results = grid_search.fit(X_train_std, y_train)\n\n\n\nCode\n# get the best accuracy achieved\nprint(\"Best accuracy\", grid_results.best_score_)\nprint(\"Best K value\", grid_results.best_estimator_.get_params()['n_neighbors'])\n\n\nBest accuracy 0.9271142857142858\nBest K value 3\n\n\n\n\nCode\nplt.plot(hyper_params['n_neighbors'], grid_search.cv_results_['mean_test_score'])\nplt.title('Cross validated grid search results'.title())\nplt.show()\n\n\n\n\n\n\nFeature Engineering\n\nCode\n%%capture\n\n# fit the KNN with best K value\nknn_best = KNeighborsClassifier(n_neighbors=3)\nknn_best_fit = knn.fit(X_train_std, y_train)\n\nr = permutation_importance(\n    knn,\n    X_train_std,\n    y_train,\n    n_repeats=5,\n    random_state=123,\n    n_jobs=-1,\n)\n\n\n\nCode\nfeat = pd.DataFrame({\n    'feature': X_train.columns,\n    'importance': r.importances_mean,\n}).sort_values('importance')\n\nplt.scatter(data=feat, x='importance', y='feature')\nplt.xlabel(\"Importance\")\nplt.title('feature interpretation'.title())\nplt.show()"
  },
  {
    "objectID": "KNN_and_XGB.html#basic-gradient-boosting-model",
    "href": "KNN_and_XGB.html#basic-gradient-boosting-model",
    "title": "KNN & XGB",
    "section": "Basic Gradient Boosting Model",
    "text": "Basic Gradient Boosting Model\n\n\nCode\n# create XGBClassifier model\nxgb_model = xgb.XGBClassifier()\n\n# create 5-Fold CV\nkfold = KFold(n_splits=5, random_state=123, shuffle=True)\n\n# Fit the model\nresults = cross_val_score(xgb_model, X_train, y_train, cv=kfold, scoring='accuracy')\n\nprint(max(results))\n\n\n0.9791428571428571\n\n\n\nWith Randomized Searching\n\nCode\nparam_distributions = {\n    'n_estimators': [1000, 2500, 5000],\n    'learning_rate': [0.001, 0.01, 0.1],\n    'max_depth': [3, 5, 7, 9],\n    'min_child_weight': [1, 5, 15]\n}\n\nrandom_search = RandomizedSearchCV(\n    xgb_model,\n    param_distributions,\n    n_iter=5,\n    cv=kfold,\n    scoring='accuracy',\n    random_state=123,\n    n_jobs=-1,\n)\n\nsearch_results = random_search.fit(X_train_std, y_train)\n\n\n\nCode\nsearch_results.best_score_\n\n\n0.9789571428571427"
  }
]